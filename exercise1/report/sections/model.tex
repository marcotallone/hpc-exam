\documentclass[../main.tex]{subfiles}

% Importing images from another path
\graphicspath{{\subfix{../images/}}}

\begin{document}

Throught the use of OOB programming in \cc{Python}, a model has been built in order to mimic the execution of the \textbf{broadcast} and \textbf{reduce} algorithms presented in section~\ref{algorithms}. 
The core idea has been to build an ``artificial'' architecture of the EPYC nodes used in the experiment that was able to simulate the most important aspects in the latency measurements.\\
The model (organized in a \cc{Python} module) is in fact a collection of classes and methods that accurately reproduce the internal architecture of the EPYC nodes used for the benchmark and some of the behaviours of the MPI library.
For instance, this module offers the possibility of instantiating an object of class \cc{Process} that can be binded to a specific \cc{Core}, located in one of the $2$ \cc{Socket} objects, enclosed in a \cc{Node} class. This seemingly complex structure is in truth notthing else than a simplified reproduction of the EPYC node's internal architecture. \cc{Process} objects are then given a \cc{send} method that aims to replicate the execution of a NBFT as explained in section~\ref{algorithms}. In fact, this method takes in input a list of receiving processesses and a message size, computes the relative positions of all the other processes with respect to the sender to understand which communication channels to use, and returns the latency of the NBFT estimated using equation~\ref{eq:nbft-approx}, using the fitted point-to-point latencies and the discrete function $\widehat{\gamma}^{c}(P,m)$ obtained in equation~\ref{eq:gamma-discrete}.\\
In other words, this model can accurately reproduce the execution time of an arbitrairly large NBFT for any message size. According to equations~\ref{eq:chain-time} and~\ref{eq:binary-time}, this can then be used to also estimate the execution time of the \textbf{chain} and \textbf{binary tree} algorithms. However, a problem that this model had to face was the situation in which more than one communication channel was used in the same NBFT.\ Figures~\ref{fig:algorithms}b and~\ref{fig:algorithms}c show this exact situation where links in red and green are used to indentify two different communication channels. As explained, this model takes into account $4$ possible communication channels, ordered according to:
\begin{equation}\label{eq:channels-order}
c_i \geq c_j \quad \Leftrightarrow \quad T^{c_{i}}_{p2p}(m) \geq T^{c_{j}}_{p2p}(m) \quad ,\; \forall m,\; \forall i,j \in \{0,1,2,3\}
\end{equation}
Therefore, this model assumes that:
\begin{equation}\label{eq:q-factor}
    T^{c_{i}}_{p2p}(m) = Q_{i,j}(m) \cdot T^{c_{j}}_{p2p}(m) \quad ,\; \forall m,\; \forall i,j \in \{0,1,2,3\} | \; i > j
\end{equation}
where $Q_{i,j}(m)$ is a platform-dependent but algorithm-independent parameter ($Q_{i,j}(m) \geq 1$) representing the \textit{ratio of delayes} between any two communication channels $c_i$ and $c_j$. This parameter is easily estimated using the fitted values for the point-to-point communication in equation~\ref{eq:hockney} as follows:
\begin{equation}\label{eq:q-factor-estimate}
    Q_{i,j}(m) = \frac{\widehat{T}^{c_{i}}_{p2p}(m)}{\widehat{T}^{c_{j}}_{p2p}(m)} \quad ,\; \forall m,\; \forall i,j \in \{0,1,2,3\} | \; i > j
\end{equation}
Therefore, the execution time $T_{NBFT}$ of a NBFT $\mathbf{A}$ using multiple channels is calculated as the time $T^{c_{\max}}_{NBFT}$ of the NBFT $\mathbf{B}$ that only uses the highest-order channel, obtained from $\mathbf{A}$ by formal replacement of of each group of $Q_{\max,j}(m)$ point-to-point communications in channel $c_j$ with a single point-to-point communication in channel $c_{\max}$, where $c_{\max}$ is the highest-order channel used in $\mathbf{A}$ while $c_j$ can be any lower-order channel. Formally, by labelling with $N_i$ the number of point-to-point communication through channel $c_i$, this yields the following equation:
\begin{equation}\label{eq:nbft-multi}
    T_{NBFT}(P,m) =
    \begin{cases}
        T^{c_0}_{NBFT}(P,m) & \text{if } c_{\max} = c_0 \\
        T^{c_1}_{NBFT}(N_1 + \lfloor \frac{N_0}{Q_{1,0}(m)} \rfloor+1,m) & \text{if } c_{\max} = c_1 \\
        T^{c_2}_{NBFT}(N_2 + \lfloor \frac{N_1}{Q_{2,1}(m)} \rfloor+ \lfloor \frac{N_0}{Q_{2,0}(m)} \rfloor+1,m) & \text{if } c_{\max} = c_2 \\
        T^{c_3}_{NBFT}(N_3 + \lfloor \frac{N_2}{Q_{3,2}(m)} \rfloor+ \lfloor \frac{N_1}{Q_{3,1}(m)} \rfloor+ \lfloor \frac{N_0}{Q_{3,0}(m)} \rfloor+1,m) & \text{if } c_{\max} = c_3 \\
    \end{cases}
\end{equation}
where again, each $T^{c_i}_{NBFT}(P,m)$ is computed according to equation~\ref{eq:nbft-approx}, using the fitted values for the point-to-point communications and the \textit{parallelization factor} found in section~\ref{architecture}.\\
This concretely solves the problem of computing NBFT latencies with multiple concurrent communication channels and practically enables the model to predict the execution time of the collective operation algorithms in all possible scenarios.\\

\end{document}